// ************
// *модуль mux*
// ************
// Мультиплексор.
// 
// Кусок (подшина) входной шины, определяемый подаваемым на вход номером, непрерывно перенаправляется на выход.
// 
// = Входы =
// [шина] in [W*N     ]: входные данные.
// [шина] n  [bits4(N)]: номер куска.
//
// = Выходы =
// [шина] out [W]: выходные данные.
//
// = Параметры =
// [integer] W [1]: ширина выходных данных и каждого куска входных данных.
// [integer] N [2]: общее число кусков во входных данных; должно быть хотя бы 2 куска.
// 
// = Ограничения на параметры =
// W >= 1
// N >= 1
// 
// = Функционирование =
// Входные данные разбиты на N кусков chunk(k) ширины W:
//   in == {chunk(0), chunk(1), ..., chunk(N)}
//   (в порядке, обратном порядку нумерации битов шин - для удобочитаемости при задании портов экземпляра).
// 
// * @ always:
//   если 0 <= n < N, то
//     out <- chunk(n)
//   если n >= N, то
//     out <- xx..x
// 
// = Пример использования =
// wire [4:0] in0, in1, in2;
// wire [1:0] sel;
// wire [4:0] out;
// mux #(.W(5), .N(3)) _mux({in0, in1, in2}, sel, out);
// * sel == 0 => out == in0
// * sel == 1 => out == in1
// * sel == 2 => out == in2
// * sel == 3 => out == xxxxx
// 
// = Модуль написал =
// Владислав Подымов
// 2018
// e-mail: valdus@yandex.ru
module mux(in, n, out);
  parameter integer W = 1;
  parameter integer N = 2;
  localparam CW = (N == 1)
                  ? 1
                  : $clog2(N);
  input [W*N-1:0] in;
  input [CW-1:0] n;
  output [W-1:0] out;
  
  wire [W-1:0] chunk[0:N-1];
  
  generate
    genvar k;
    for(k = 0; k < N; k = k + 1)
    begin : gen_block
      assign chunk[k] = in[W*(N-k)-1:W*(N-1-k)];
    end
  endgenerate
  
  assign out = (0 <= n && n < N)
               ? chunk[n]
               : {W{1'bx}};
endmodule

